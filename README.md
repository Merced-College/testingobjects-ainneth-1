[![Open in Codespaces](https://classroom.github.com/assets/launch-codespace-2972f46106e565e64193e422d61a12cf1da4916b45550586e14ef0a7c637dd04.svg)](https://classroom.github.com/open-in-codespaces?assignment_repo_id=22624315)
# testingObjects

this is an example of a ReadMe file.

Answers: 

Checkpoint Q1: Printing an object with no toString shows a hashed memory address, from the object library( a default constructor)[Dog@1dbd16a6]. The reason for why is that every class within java inherits from an object class(ex toString method, where the class name is utilized, an @ symbol, and a integer or the hash code of the memory address. 

Checkpoint Q2: The three fields printed, when default were; name= null
age = 0
breed = null
Things in Java thar are with capital letters ( like String) are reference types, therefore name and breed are reference types. The things that AREN'T capital are set to 0 ( int or double), and therefore age is a primitive type. 

Checkpoint Q3: Constructors change the initialization story due to the fact that programmer developer is now responsible for making the constructors, and therefore allocating the constructors' memories

Checkpoint Q4:The change between Part A's printout to Part D's is that the to String method is being called on rather than the object's memory address, allowing for data variables to be printed out. @Override is useful, when wanting to overwrite over the object, allowing the r toString method and therefore printing our object's data variables without any potential mistakes/mishaps thaat can occur with any previous methods.

Checkpoint Q5: Prefering private fields with getters/setters over private fields is due to the fact its standerized and keeps the field secure. An example of a rule would be bank transactions, that way people aren't sending or taking money from other people's bank accounts.